input {
  relp {
    port => 2514
    codec => json_lines
    ssl_enable => true
    ssl_verify => false              # TODO: true when you use a real CA
    ssl_cert => "/certs/logstash.crt"
    ssl_key  => "/certs/logstash.key"
  }
}

filter {
  # 0) Guard rails: if a line wasnâ€™t valid JSON (shouldnâ€™t happen with json_lines, but just in case)
  if "_jsonparsefailure" in [tags] {
    mutate { add_tag => ["rtds_bad_json"] }
  }

  # 1) Timestamp normalization:
  # Use @timestamp if provided (ISO). Otherwise try rtds.ts_unix_nanos, then fall back to Logstash ingest time.
  if !("@timestamp" in [@metadata]) and [rtds][ts_unix_nanos] {
    date {
      match  => ["[rtds][ts_unix_nanos]", "UNIX_NS"]
      target => "@timestamp"
    }
  }
  # If @timestamp is a string already, the json codec set it. No action needed.

  # 2) Minimal ECS mapping so Kibana Lens/SIEM works better
  # Only map if source fields exist, to avoid nil errors.
  if [rtds][event_type] and ![event][action] {
    mutate { add_field => { "[event][action]" => "%{[rtds][event_type]}" } }
  }
  if [rtds][syscall] and ![event][category] {
    mutate { add_field => { "[event][category]" => "process" } }
  }
  if ![event][kind] { mutate { add_field => { "[event][kind]" => "event" } } }
  if ![event][type] { mutate { add_field => { "[event][type]" => "info" } } }

  # File/process helpers (only if present)
  if [rtds][path] and ![file][path] {
    mutate { add_field => { "[file][path]" => "%{[rtds][path]}" } }
  }
  if [rtds][argv] and ![process][args] {
    # argv is already an array in your NDJSON; if it ever arrives as string, you can split later.
    mutate { rename => { "[rtds][argv]" => "[process][args]" } }
  }

  # 3) Type coercions (avoid mapping conflicts; ES will dynamic-map otherwise)
  mutate {
    convert => {
      "[rtds][root_pid]" => "integer"
      "[rtds][event_id]" => "integer"
      "[rtds][bytes]"    => "integer"
    }
  }

  # 4) Safer de-dup id:
  # prefer a stable field set: timestamp + root_pid + event_id + syscall + path
  fingerprint {
    source => ["@timestamp","[rtds][root_pid]","[rtds][event_id]","[rtds][syscall]","[rtds][path]"]
    method => "SHA256"
    target => "[@metadata][doc_id]"
  }

  # 5) Optional: dead-letter tag for docs that still look off
  if ![rtds][event_type] {
    mutate { add_tag => ["rtds_missing_event_type"] }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user  => "elastic"
    password => "${ELASTIC_PASSWORD}"
    ilm_enabled => true
    ilm_rollover_alias => "rtdst-syscalls"
    ilm_pattern => "000001"
    ilm_policy => "rtdst-ilm"
    index => "rtdst-syscalls-000001"
    document_id => "%{[@metadata][doc_id]}"
  }
  # For troubleshooting during bring-up:
  # stdout { codec => rubydebug }
}