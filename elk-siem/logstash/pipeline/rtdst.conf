filter {
  #
  # 0) Normalize layout: support both top-level and rtds.* payloads
  #
  # If the event is top-level (ts_ns, pid, ...), move them under [rtds]. If already under [rtds], do nothing.
  ruby {
    code => '
      unless event.get("rtds").is_a?(Hash)
        r = {}
        %w(ts_ns dur_ns root tgid pid sys ret argc a0 a1 a2 a3 comm cgroup_id path0 path1 event_type event_id).each do |k|
          v = event.get(k)
          r[k] = v unless v.nil?
        end
        # Only set [rtds] if we actually collected something
        event.set("rtds", r) unless r.empty?
      end
    '
  }

  #
  # 1) Types & safe numeric coercions
  #
  mutate {
    convert => {
      "[rtds][ts_ns]"     => "integer"
      "[rtds][dur_ns]"    => "integer"
      "[rtds][root]"      => "integer"
      "[rtds][tgid]"      => "integer"
      "[rtds][pid]"       => "integer"
      "[rtds][sys]"       => "integer"
      "[rtds][ret]"       => "integer"
      "[rtds][argc]"      => "integer"
      "[rtds][a0]"        => "integer"
      "[rtds][a1]"        => "integer"
      "[rtds][a2]"        => "integer"
      "[rtds][a3]"        => "integer"
      "[rtds][cgroup_id]" => "integer"
      "[rtds][event_id]"  => "integer"
    }
  }

  #
  # 2) Timestamp handling (ts_ns -> @timestamp), duration
  #
  if [rtds][ts_ns] {
    ruby {
      code => '
        ts = event.get("[rtds][ts_ns]")
        if ts
          event.set("@timestamp", LogStash::Timestamp.new(Time.at(ts.to_i / 1_000_000_000.0)))
        end
      '
    }
  }
  if [rtds][dur_ns] {
    mutate { add_field => { "[event][duration]" => "%{[rtds][dur_ns]}" } }
    mutate { convert    => { "[event][duration]" => "integer" } }   # ECS duration is in ns
  }

  #
  # 3) ECS: process, file, host-ish
  #
  if [rtds][pid] {
    mutate { add_field => { "[process][pid]" => "%{[rtds][pid]}" } }
  }
  if [rtds][tgid] {
    mutate { add_field => { "[process][thread][id]" => "%{[rtds][tgid]}" } }
  }
  if [rtds][root] {
    mutate { add_field => { "[process][parent][pid]" => "%{[rtds][root]}" } }
  }
  if [rtds][comm] {
    mutate { add_field => { "[process][name]" => "%{[rtds][comm]}" } }
  }
  if [rtds][argc] {
    mutate { add_field => { "[process][args_count]" => "%{[rtds][argc]}" } }
    mutate { convert    => { "[process][args_count]" => "integer" } }
  }
  if [rtds][path0] and [rtds][path0] != "" {
    mutate { add_field => { "[file][path]" => "%{[rtds][path0]}" } }
  }
  if [rtds][path1] and [rtds][path1] != "" {
    mutate { add_field => { "[file][target_path]" => "%{[rtds][path1]}" } }
  }
  if [rtds][cgroup_id] {
    # Not strictly ECS, but useful to nest
    mutate { add_field => { "[container][cgroup][id]" => "%{[rtds][cgroup_id]}" } }
    mutate { convert    => { "[container][cgroup][id]" => "integer" } }
  }

  #
  # 4) ECS: event classification
  #
  # Default classification for syscalls
  mutate {
    add_field => {
      "[event][kind]"     => "event"
      "[event][category]" => "process"
    }
  }
  # action = explicit rtds.event_type if present, else "syscall:<num>"
  if [rtds][event_type] {
    mutate { add_field => { "[event][action]" => "%{[rtds][event_type]}" } }
  } else if [rtds][sys] {
    mutate { add_field => { "[event][action]" => "syscall:%{[rtds][sys]}" } }
  }

  # Rough event.type based on return value or discrete events
  ruby {
    code => '
      act  = event.get("[event][action]")
      ret  = event.get("[rtds][ret]")
      types = []
      if act.is_a?(String) && act.start_with?("EVENT_")
        # e.g. EVENT_SERVICE_STOP, EVENT_PROCESS_DISCOVERY
        types << "info"
      else
        # syscall heuristic: non-negative ret = success
        if ret.is_a?(Numeric) && ret >= 0
          types << "start"
        else
          types << "error"
        end
      end
      event.set("[event][type]", types) unless types.empty?
    '
  }

  #
  # 5) Preserve raw args as an array (handy in Kibana)
  #
  ruby {
    code => '
      args = []
      %w(a0 a1 a2 a3).each do |k|
        v = event.get("[rtds][#{k}]")
        args << v if v
      end
      event.set("[rtds][args]", args) unless args.empty?
    '
  }

  #
  # 6) Document identity (stable _id to deduplicate)
  #
  fingerprint {
    source => ["@timestamp","[rtds][root]","[rtds][tgid]","[rtds][pid]","[event][action]","[file][path]"]
    method => "SHA256"
    target => "[@metadata][doc_id]"
  }

  #
  # 7) Cosmetic: tag dataset/module (good for Kibana)
  #
  mutate {
    add_field => {
      "[event][module]"  => "rtds"
      "[event][dataset]" => "rtds.syscalls"
    }
  }
}